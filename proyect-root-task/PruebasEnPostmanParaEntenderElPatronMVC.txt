Pruebas en Postman para entender el patrón MVC

1. Obtener todas las tareas (GET)

  Justificación: Esta prueba permite a los estudiantes visualizar 
  cómo la aplicación MVC maneja una solicitud para obtener los datos 
  almacenados en el archivo 'tareas.txt'. En este caso, el controlador 
  interactúa con el servicio, que a su vez llama a la capa de 
  persistencia para devolver todas las tareas.
    
    • Método HTTP: GET
    • URL: http://localhost:3000/tareas
    • Descripción: Devuelve una lista de todas las tareas.
    • Respuesta esperada:
    [
      {"id": 1, "titulo": "Tarea 1", "descripcion": "Descripción de tarea 1", "completado": false}
      {"id": 2, "titulo": "Tarea 2", "descripcion": "Descripción de tarea 2", "completado": true}
      {"id": 3, "titulo": "Tarea 3", "descripcion": "Descripción de tarea 3", "completado": true}
    ]


2. Obtener tareas completadas (GET)
  Justificación: Esta prueba muestra cómo el servicio filtra los datos, 
  ya que solo queremos obtener las tareas que están marcadas como completadas.
    • Método HTTP: GET
    • URL: http://localhost:3000/tareas/completadas
    • Descripción: Devuelve solo las tareas completadas.
    • Respuesta esperada:
    [
      {"id": 2, "titulo": "Tarea 2", "descripcion": "Descripción de tarea 2", "completado": true}
      {"id": 3, "titulo": "Tarea 3", "descripcion": "Descripción de tarea 3", "completado": true}
    ]


3. Añadir una nueva tarea (POST)
  Justificación: Con esta prueba, los estudiantes aprenden cómo el MVC 
  maneja la creación de nuevos datos. Aquí, el controlador recibe los 
  datos enviados a través de la solicitud y se los pasa al servicio, que 
  los valida y los guarda en el archivo.
    • Método HTTP: POST
    • URL: http://localhost:3000/tareas
    • Descripción: Crea una nueva tarea.
    • Cuerpo (Body):
    {
      "id": 4,
      "titulo": "Tarea 4",
      "descripcion": "Descripción de tarea 4",
      "completado": false
    }
    • Respuesta esperada:
    {
      "message": "Tarea creada con éxito"
    }


4. Marcar tarea como completada (PUT)
  Justificación: Esta prueba permite entender cómo actualizar un 
  recurso en el patrón MVC. El controlador recibe la solicitud de 
  actualización, el servicio modifica la tarea y la persistencia 
  actualiza el archivo.
    • Método HTTP: PUT
    • URL: http://localhost:3000/tareas/1/completar
    • Descripción: Marca la tarea con 'id = 1' como completada.
    • Respuesta esperada:
    {
      "message": "Tarea marcada como completada"
    }


5. Eliminar una tarea (DELETE)
  Justificación: Finalmente, esta prueba muestra cómo el MVC maneja 
  la eliminación de recursos. El controlador recibe la solicitud de 
  eliminar una tarea, el servicio se asegura de que exista, y el 
  repositorio elimina la tarea del archivo.
    • Método HTTP: DELETE
    • URL: http://localhost:3000/tareas/1
    • Descripción: Elimina la tarea con 'id = 1'.
    • Respuesta esperada:
    {
      "message": "Tarea eliminada con éxito"
    }


Explicación general de las pruebas en Postman:
  Estas pruebas enseñan a los estudiantes cómo funciona cada componente 
  del patrón MVC:
    • Modelo: Representa las tareas.
    • Vista: Devuelve las tareas en formato JSON.
    • Controlador: Gestiona las solicitudes y respuestas.
    • Servicio: Procesa la lógica de negocio (filtrado, validación).
    • Persistencia: Lee y escribe datos en un archivo de texto.

Conclusión
  Con esta implementación basada en MVC en Node.js, hemos logrado:
    1. Separar claramente las responsabilidades de cada capa (Modelo, 
      Vista, Controlador, Servicio y Persistencia).
    2. Utilizar un nivel de abstracción en la capa de persistencia 
      para facilitar la transición a otras fuentes de datos en el futuro.
    3. Crear una aplicación que lee datos desde un archivo de texto 
      utilizando la API de Node.js (fs) y los presenta al usuario en 
      formato JSON. 

Este enfoque modular permite que la aplicación sea fácil de mantener y 
escalar, con la flexibilidad de cambiar la fuente de datos en el futuro 
sin necesidad de modificar la lógica de negocio.